#!/bin/bash

# This file is automatically generated by tools/build.sh
# Source file: scripts/syncdb-mysql.sh

# import from syncdb-mysql.sh
_m_='♥'

SHELL_NAME="MySQL Database Synchronizer"
SHELL_DESC="Efficiently synchronize MySQL databases between remote and local environments, supporting backup and restore operations."

PARAMTERS=(
  "--help${_m_}-h${_m_}Print help message.${_m_}false"
  "--debug${_m_}${_m_}Print debug message.${_m_}false"

  "--network${_m_}${_m_}Specify network environment (e.g., 'in-china').${_m_}default"

  "--db-version${_m_}${_m_}The version of the database.${_m_}8.0"
  "--docker-image-quick-check${_m_}${_m_}Is there a local quick detection of the docker image.${_m_}false"

  "--from-hostname${_m_}${_m_}The hostname of the source database.${_m_}127.0.0.1"
  "--from-port${_m_}${_m_}The port of the source database.${_m_}3306"
  "--from-username${_m_}${_m_}The username of the source database.${_m_}root"
  "--from-password${_m_}${_m_}The password of the source database.${_m_}12345678"
  "--from-database${_m_}${_m_}The database name of the source database.${_m_}mysql"

  "--to-hostname${_m_}${_m_}The hostname of the target database.${_m_}127.0.0.1"
  "--to-port${_m_}${_m_}The port of the target database.${_m_}3306"
  "--to-username${_m_}${_m_}The username of the target database.${_m_}root"
  "--to-password${_m_}${_m_}The password of the target database.${_m_}12345678"
  "--to-database${_m_}${_m_}The database name of the target database.${_m_}mysql_backup"
  "--temp${_m_}${_m_}The temporary directory.${_m_}/tmp/hz-9/env-prepare/sync-db-mysql"
)

SUPPORT_OS_LIST=(
  "Ubuntu 20.04 AMD64"
  "Ubuntu 22.04 AMD64"
  "Ubuntu 24.04 AMD64"

  "Debian 11.9 AMD64"
  "Debian 12.2 AMD64"

  "Fedora 41 AMD64"

  "RedHat 8.10 AMD64"
  "RedHat 9.6 AMD64"
)

# Import dependency: ./__base.sh
# import from ./__base.sh
_m_='♥'

# Universal parameter parsing functions - compatible with different bash versions
{
  # Detect bash version and choose appropriate parsing method
  parse_param_string() {
    local param_string="$1"
    local result_var_name="$2"
    
    # Use printf to replace separators, avoiding bash version differences
    eval "${result_var_name}=()"
    local param_with_newlines
    param_with_newlines=$(printf '%s\n' "${param_string//$_m_/$'\n'}")
    local line_count=0
    while IFS= read -r line; do
      eval "${result_var_name}[$line_count]='$line'"
      ((line_count++))
    done <<< "$param_with_newlines"
  }
  
  # Convenience function: parse parameters with 2 fields (name, value)
  parse_param_2fields() {
    local param_string="$1"
    local name_var="$2"
    local value_var="$3"
    
    parse_param_string "$param_string" "__temp_fields"
    
    eval "${name_var}=\"\${__temp_fields[0]:-}\""
    eval "${value_var}=\"\${__temp_fields[1]:-}\""
  }
  
  # Convenience function: parse parameters with 4 fields (name, alias, msg, default)
  parse_param_4fields() {
    local param_string="$1"
    local name_var="$2"
    local alias_var="$3"
    local msg_var="$4"
    local default_var="$5"
    
    parse_param_string "$param_string" "__temp_fields"
    
    eval "${name_var}=\"\${__temp_fields[0]:-}\""
    eval "${alias_var}=\"\${__temp_fields[1]:-}\""
    eval "${msg_var}=\"\${__temp_fields[2]:-}\""
    eval "${default_var}=\"\${__temp_fields[3]:-}\""
  }
}

# Const
{
  get_outline_package() {
    local packageName="$1"
    echo "${HOME}"/Downloads/"$packageName"
  }

  # to_windows_path_format() {
  #   local original_path=$1
  #   local windows_path
  #   windows_path=$(echo "$original_path" | sed 's|^/c/|C:\\|' | sed 's|/|\\|g')
  #   echo "$windows_path"
  # }

  to_windows_path_format() {
    local original_path=$1
    local windows_path
    windows_path=$(echo "$original_path" | sed 's|^/\([a-zA-Z]\)/|\1:\\|' | sed 's|/|\\|g')
    echo "$windows_path"
  }

  to_git_bash_path_format() {
    local original_path=$1
    local git_bash_path
    git_bash_path=$(echo "$original_path" | sed 's|^\([a-zA-Z]\):|/\1|' | sed 's|\\|/|g')
    echo "$git_bash_path"
  }
}

# OS Module
{
  OS_NAME=''
  OS_VERS=''
  OS_ARCH=''
  CURRENT_OS=''

  OS_IS_WINDOWS=false
  OS_IS_LINUX=false
  OS_IS_MACOS=false
  OS_IS_SUPPORT=false

  # Parse current operating system information
  os_parse_info() {
    # Raw operating system information before formatting
    local __BASE_OS_NAME__
    local __BASE_OS_VERS__
    local __BASE_OS_ARCH__

    if [ -f /etc/os-release ]; then
      . /etc/os-release
      # shellcheck disable=SC2153
      __BASE_OS_NAME__=$NAME
      __BASE_OS_VERS__=$VERSION_ID
      __BASE_OS_ARCH__=$(uname -m)
    else
      __BASE_OS_NAME__=$(uname -s)
      __BASE_OS_VERS__=$(uname -r)
      __BASE_OS_ARCH__=$(uname -m)
    fi

    # -------------------- judge os name --------------------

    parse_os_name() {
      if [[ "$__BASE_OS_NAME__" == "Debian GNU/Linux" ]]; then
        echo "Debian"
      elif [[ "$__BASE_OS_NAME__" == "Fedora Linux" ]]; then
        echo "Fedora"
      elif [[ "$__BASE_OS_NAME__" == "Alibaba Cloud Linux" ]]; then
        echo "AlibabaCloudLinux"
      elif [[ "$__BASE_OS_NAME__" == "Red Hat Enterprise Linux" ]]; then
        echo "RedHat"
      elif [[ "$__BASE_OS_NAME__" == "MINGW"* ]] || [[ "$__BASE_OS_NAME__" == "CYGWIN"* ]] || [[ "$__BASE_OS_NAME__" == "MSYS"* ]] || [[ "$__BASE_OS_NAME__" == "Windows_NT" ]]; then
        # Read from 'registry' to determine the Windows version
        local productName
        productName=$(powershell.exe -Command "(Get-ItemProperty 'HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion').ProductName" | tr -d '\r')
        if [[ "$productName" == "Windows Server 2019"* ]] || [[ "$productName" == "Windows Server 2022"* ]]; then
          echo "WindowsServer"
        else 
          echo "No Support Windows Version"
        fi
      elif [[ "$__BASE_OS_NAME__" == "Darwin" ]]; then
        echo "MacOS"
      else
        echo "$__BASE_OS_NAME__"
      fi
    }

    # shellcheck disable=SC2155
    local _OS_NAME=$(parse_os_name)
    is_window_system() {
      if [[ "$_OS_NAME" == "WindowsServer" ]]; then
        return 0
      else
        return 1
      fi
    }
    is_linux_system() {
      if [[ "$_OS_NAME" == "Ubuntu" ]] || [[ "$_OS_NAME" == "Debian" ]] || [[ "$_OS_NAME" == "Fedora" ]] || [[ "$_OS_NAME" == "RedHat" ]] || [[ "$_OS_NAME" == "AlibabaCloudLinux" ]]; then
        return 0
      else
        return 1
      fi
    }
    is_macos_system() {
      if [[ "$_OS_NAME" == "MacOS" ]]; then
        return 0
      else
        return 1
      fi
    }

    if is_window_system; then
      OS_NAME=$_OS_NAME
      OS_IS_WINDOWS=true
    elif is_linux_system; then
      OS_NAME=$_OS_NAME
      OS_IS_LINUX=true
    elif is_macos_system; then
      OS_NAME=$_OS_NAME
      OS_IS_MACOS=true
    else
      OS_NAME='Unknown'
    fi

    # -------------------- judge os version -----------------

    parse_os_version() {
      if [[ "$OS_NAME" == "MacOS" ]]; then
        sw_vers -productVersion
      elif [[ "$OS_NAME" == "Debian" ]]; then
        cat /etc/debian_version
      elif [[ "$OS_NAME" == "AlibabaCloudLinux" ]]; then
        . /etc/os-release
        echo "$PRETTY_NAME" | awk '{print $4}'
      elif [[ "$OS_NAME" == "WindowsServer" ]]; then
        local productName
        productName=$(powershell.exe -Command "(Get-ItemProperty 'HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion').ProductName" | tr -d '\r')
        echo "$productName" | awk '{print $3}'
      else
        echo "$__BASE_OS_VERS__"
      fi
    }

    OS_VERS=$(parse_os_version)

    # -------------------- judge os arch --------------------

    parse_os_arch() {
      if [[ "$__BASE_OS_ARCH__" == "arm64" ]]; then
        echo "ARM64"
      elif [[ "$__BASE_OS_ARCH__" == "x86_64" ]]; then
        echo "AMD64"
      else
        echo "$__BASE_OS_ARCH__"
      fi
    }

    OS_ARCH=$(parse_os_arch)
    CURRENT_OS="$OS_NAME $OS_VERS $OS_ARCH"

    is_support_current_os() {
      if [[ -z "$SUPPORT_OS_LIST" ]]; then
        SUPPORT_OS_LIST=()
        # echo "${RED}Error:${NC} \$SUPPORT_OS_LIST is not set. But is_support_current_os() is called."
        # return 1
      fi

      for os_info in "${SUPPORT_OS_LIST[@]}"; do
        # Use read to split each element into three parts
        read -r current_os_name current_os_vers current_os_arch <<<"$os_info"
        # echo "OS name: $current_os_name"
        # echo "Version: $current_os_vers"
        # echo "Architecture: $current_os_arch"

        if [[ "$current_os_name" == "$OS_NAME" ]] && [[ "$current_os_vers" == "$OS_VERS" ]] && [[ "$current_os_arch" == "$OS_ARCH" ]]; then
          return 0
        fi
      done
      return 1
    }

    if is_support_current_os; then
      OS_IS_SUPPORT=true
    fi
  }

  os_parse_info

  print_system_info() {
    echo "OS_NAME    : $OS_NAME"
    echo "OS_VERSION : $OS_VERS"
    echo "OS_ARCH    : $OS_ARCH"
    echo "CURRENT_OS : $CURRENT_OS"
  }

  print_system_extra_info() {
    print_system_info
    echo "IS_WINDOWS : $IS_WINDOWS"
    echo "IS_LINUX   : $IS_LINUX"
    echo "IS_MACOS   : $IS_MACOS"
  }

  USE_APT_GET_INSTALL=false
  USE_DNF_INSTALL=false

  if [[ "$OS_NAME" == "Ubuntu" ]] || [[ "$OS_NAME" == "Debian" ]]; then
    USE_APT_GET_INSTALL=true
  elif [[ "$OS_NAME" == "Fedora" ]] || [[ "$OS_NAME" == "RedHat" ]] || [[ "$OS_NAME" == "AlibabaCloudLinux" ]]; then
    USE_DNF_INSTALL=true
  fi
}

# Console Module
{
  RED='\033[0;31m'
  GREEN='\033[0;32m'
  YELLOW='\033[0;33m'
  BLUE='\033[0;34m'
  PURPLE='\033[0;35m'
  CYAN='\033[0;36m'
  WHITE='\033[0;37m'
  NC='\033[0m' # no color

  # Print current time (seconds)
  console_time_s() {
    local seconds
    seconds=$(date +%s)
    echo $((seconds * 1))
  }

  # Print script name (using purple color)
  # Required variable: $SHELL_NAME
  console_script_name() {
    if [[ -z "$SHELL_NAME" ]]; then
      echo "${RED}Error:${NC} \$SHELL_NAME is not set. But console_script_name() is called."
      return 1
    fi

    printf "\n${PURPLE}%s${NC}\n\n" "$SHELL_NAME"
  }

  # Print script description
  # Required variable: $SHELL_DESC
  console_script_desc() {
    if [[ -n "$SHELL_DESC" ]]; then
      printf "  ${NC}%s${NC}\n\n" "$SHELL_DESC"
    fi
  }

  # Print supported operating system list in fixed format
  # Required variable: $SUPPORT_OS_LIST
  console_support_os_list() {
    # shellcheck disable=SC2128
    if [[ -z "$SUPPORT_OS_LIST" ]]; then
      echo "${RED}Error:${NC} \$SUPPORT_OS_LIST is not set. But console_os_list() is called."
      return 1
    fi

    printf "  ${YELLOW}%s${NC}\n\n" "Supported operating systems:"
    for SUPPORT_OS_ITEM in "${SUPPORT_OS_LIST[@]}"; do
      printf "    ${YELLOW}%s${NC}\n" "$SUPPORT_OS_ITEM"
    done

    console_empty_line
  }

  # Check if current system is supported and output message
  console_check_system() {
    if [[ -z "$OS_IS_SUPPORT" ]]; then
      echo "${RED}Error:${NC} \$OS_IS_SUPPORT is not set. But console_check_system() is called."
    fi

    if [[ "$OS_IS_SUPPORT" == false ]]; then
      printf "  ${RED}%s${NC}\n\n" "This shell script does not support the current operating system. [$CURRENT_OS]"
    else
      printf "  ${GREEN}%s${NC}\n\n" "This shell script supports the current operating system. [$CURRENT_OS]"
    fi
  }

  # Print module title (cyan color)
  console_module_title() {
    local title="$1"
    printf "  ${CYAN}%s${NC}\n\n" "$title"
  }

  # Print information in key-value format (green color)
  console_key_value() {
    local key="$1"
    local value="$2"

    if [[ ${#key} -gt 16 ]]; then
      printf "    ${GREEN}%s${NC}\n" "$key"
      printf "    ${GREEN}%-16s${NC}: %s\n" "" "$value"
    else
      printf "    ${GREEN}%-16s${NC}: %s\n" "$key" "$value"
    fi

    return 1
  }

  # Print empty line
  console_empty_line() {
    printf "\n"
  }

  # # Regular print (0 space indent)
  # console_content() {
  #   printf "%s\n" "$1"
  # }

  # Print content (4 space indent)
  console_content() {
    printf "    %s\n" "$1"
  }

  # Convert multi-line content to 4-space indented format
  console_sulines() {
    local msg=$1
    _console_sub_lines() {
      while IFS= read -r line; do
        printf "      %s\n" "$line"
      done
    }
    echo "$msg" | _console_sub_lines
  }

  tempTime=$(console_time_s)
  # Print module start line output content
  console_content_starting() {
    if ! declare -f get_param >/dev/null; then
      echo "${RED}Error:${NC} function get_param is not declared. But console_content_starting() is called."
      return 1
    fi

    tempTime=$(console_time_s)

    if [ "$(get_param '--debug')" == 'false' ]; then
      printf "    %s" "$1"
    else
      printf "    %s\n\n" "$1"
    fi
  }

  # Print module complete line output content
  console_content_complete() {
    if ! declare -f get_param >/dev/null; then
      echo "${RED}Error:${NC} function get_param is not declared. But console_content_complete() is called."
      return 1
    fi

    local currentTime
    currentTime=$(console_time_s)
    local timeDiff
    timeDiff=$((currentTime - tempTime))

    if [ "$(get_param '--debug')" == 'false' ]; then
      printf " ${GREEN}%s${NC} %s${NC}\n" "done." "(${timeDiff} s)"
    else
      printf "\n ${GREEN}%s${NC} %s${NC}\n" "done." "(${timeDiff} s)"
    fi
  }

  # Print module error line output content
  console_content_error() {
    if ! declare -f get_param >/dev/null; then
      echo "${RED}Error:${NC} function get_param is not declared. But console_content_error() is called."
      return 1
    fi

    local msg=$1

    if [ "$(get_param '--debug')" == 'false' ]; then
      printf " ${RED}%s${NC}\n" "error."
      printf "    ${RED}%s${NC}\n" "Reason: \"${msg}\""
    else
      printf "\n ${RED}%s${NC}\n" "error."
      printf "    ${RED}%s${NC}\n" "Reason: \"${msg}\""
    fi
  }

  # # Print empty string
  # console_content_emptystr() {
  #   printf "%s\n" ""
  # }

  # Print script end information (cyan color)
  console_script_end() {
    printf "  ${CYAN}%s${NC}\n\n" "$1"
  }

  # Get redirect output command (based on debug parameter)
  console_redirect_output() {
    if ! declare -f get_param >/dev/null; then
      echo "${RED}Error:${NC} function get_param is not declared. But console_redirect_output() is called."
      return 1
    fi

    if [ "$(get_param '--debug')" == 'false' ]; then
      echo "&> /dev/null"
    else
      echo ""
    fi
  }
}

# Parse User Paramters
{
  USER_PARAMTERS=()

  parse_user_param() {
    while [[ "$#" -gt 0 ]]; do
      case $1 in
      --*=*)
        key="${1%%=*}"
        value="${1#*=}"
        USER_PARAMTERS+=("$key${_m_}$value")
        ;;
      --*)
        key="$1"
        if [[ -n "$2" && "$2" != --* ]]; then
          USER_PARAMTERS+=("$key${_m_}$2")
          shift
        else
          USER_PARAMTERS+=("$key${_m_}true")
        fi
        ;;
      -*=*)
        key="${1%%=*}"
        value="${1#*=}"
        USER_PARAMTERS+=("$key${_m_}$value")
        ;;
      -*)
        key="$1"
        if [[ -n "$2" && "$2" != --* ]]; then
          USER_PARAMTERS+=("$key${_m_}$2")
          shift
        else
          USER_PARAMTERS+=("$key${_m_}true")
        fi
        ;;
      *)
        echo "Unknown option: $1"
        exit 1
        ;;
      esac
      shift
    done
  }

  print_user_param() {
    console_module_title "User paramters:"

    # shellcheck disable=SC2128
    if [[ -z "$USER_PARAMTERS" ]]; then
      echo "${RED}Error:${NC} \$USER_PARAMTERS is not set. But print_user_param() is called."
      return 1
    fi

    for PARAMTER in "${USER_PARAMTERS[@]}"; do
      local name value
      parse_param_2fields "$PARAMTER" name value
      # echo "name: $name"
      # echo "value: $value"
      console_key_value "${name//--/}" "$value"
    done
    echo ""

    return 1
  }

  # Check if user parameter exists.
  # eg:
  #  has_user_param --a
  has_user_param() {
    local key="$1"

    for PARAMTER in "${USER_PARAMTERS[@]}"; do
      local name value
      parse_param_2fields "$PARAMTER" name value
      # echo "name: $name"
      # echo "value: $value"

      if [[ "$name" == "$key" ]]; then
        return 0
      fi
    done

    return 1
  }

  get_user_param() {
    local key="$1"

    for PARAMTER in "${USER_PARAMTERS[@]}"; do
      local name value
      parse_param_2fields "$PARAMTER" name value
      # echo "name: $name"
      # echo "value: $value"

      if [[ "$name" == "$key" ]]; then
        echo "$value"
      fi
    done
    return
  }

  parse_user_param "$@"
}

# Parse Paramters
{
  print_default_param() {
    console_module_title "Default paramters:"

    if [[ -z "$PARAMTERS" ]]; then
      echo "${YELLOW}Warn:${NC} \$PARAMTERS is not set. Set default paramters."
      PARAMTERS=(
        "--help${_m_}-h${_m_}Print help message.${_m_}false"
        "--debug${_m_}${_m_}Print debug message.${_m_}false"
      )
    fi

    for PARAMTER in "${PARAMTERS[@]}"; do
      local name alias msg default
      parse_param_4fields "$PARAMTER" name alias msg default
      # echo "name: $name"
      # echo "alias: $alias"
      # echo "msg: $msg"
      # echo "default: $default"
      console_key_value "${name//--/}" "$default"
    done
    console_empty_line

    return 1
  }

  print_help_param() {
    for PARAMTER in "${PARAMTERS[@]}"; do
      local name alias msg default
      parse_param_4fields "$PARAMTER" name alias msg default
      # echo "name: $name"
      # echo "alias: $alias"
      # echo "msg: $msg"
      # echo "default: $default"

      if [[ -n "$alias" ]]; then
        name+=",$alias"
      fi
      local defaultStr=''
      if [[ -n "$default" ]]; then
        defaultStr=" (Default is '$default')"
      fi
      
      console_key_value "$name" "$msg$defaultStr"
    done
  }

  print_default_with_user_param() {
    console_module_title "Paramters:"

    for PARAMTER in "${PARAMTERS[@]}"; do
      local name alias msg default
      parse_param_4fields "$PARAMTER" name alias msg default
      
      local value
      value=$(get_param "$name")

      console_key_value "${name//--/}" "$value"
    done
    console_empty_line
  }

  has_param() {
    local key="$1"

    for PARAMTER in "${USER_PARAMTERS[@]}"; do
      local name value
      parse_param_2fields "$PARAMTER" name value
      # echo "name: $name"
      # echo "value: $value"

      if [[ "$name" == "$key" ]]; then
        return 0
      fi
    done

    return 1
  }

  get_param() {
    local key="$1"

    for PARAMTER in "${PARAMTERS[@]}"; do
      local name alias msg default
      parse_param_4fields "$PARAMTER" name alias msg default

      if [[ "$name" == "$key" ]]; then
        if has_user_param "$name"; then
          get_user_param "$name"
        elif has_user_param "$alias"; then
          get_user_param "$alias"
        else
          echo "$default"
        fi
        break
      fi
    done

    return
  }

  print_help_or_param() {
    if [[ $(get_param '--help') == "true" ]]; then      
      console_script_name

      console_script_desc

      print_help_param
    
      console_empty_line

      console_check_system

      console_support_os_list

      exit 0
    else
      console_script_name

      console_script_desc

      console_check_system

      if [[ "$OS_IS_SUPPORT" == false ]]; then
        console_support_os_list
        exit 1
      fi

      print_default_with_user_param
    fi
  }
}

# apt install or dnf install
{
  # Install basic environment dependencies
  apt_install_base_packages() {
    console_content_starting "Installing essential packages (ca-certificates, lsb-release)..."
    
    # First try to update with original sources, install only the most basic packages
    eval "sudo apt-get update $(console_redirect_output)" || true
    eval "sudo apt-get install -y ca-certificates lsb-release $(console_redirect_output)" || true
    
    console_content_complete
  }

  # Select appropriate mirrors based on Ubuntu version
  apt_setup_ubuntu_mirrors_set_china_mirrors() {
    local ubuntu_codename
    ubuntu_codename=$(lsb_release -cs 2>/dev/null || echo "jammy")
    
    # Completely replace /etc/apt/sources.list to ensure only USTC mirrors are used
    sudo tee /etc/apt/sources.list > /dev/null <<EOF
# USTC Ubuntu mirror source - complete replacement of all official sources
deb http://mirrors.huaweicloud.com/ubuntu/ ${ubuntu_codename} main restricted universe multiverse
deb http://mirrors.huaweicloud.com/ubuntu/ ${ubuntu_codename}-updates main restricted universe multiverse
deb http://mirrors.huaweicloud.com/ubuntu/ ${ubuntu_codename}-backports main restricted universe multiverse

# Security updates also use USTC mirrors
deb http://mirrors.huaweicloud.com/ubuntu/ ${ubuntu_codename}-security main restricted universe multiverse
EOF
    
    # Remove potentially existing default source configurations
    sudo rm -f /etc/apt/sources.list.d/ubuntu.sources 2>/dev/null || true
  }

  # Select appropriate mirrors based on Debian version
  apt_setup_debian_mirrors_set_china_mirrors() {
    local debian_codename
    debian_codename=$(lsb_release -cs 2>/dev/null || echo "bullseye")

    if [[ "$OS_VERS" == "12" ]]; then
      # Debian 12 supports non-free-firmware component
    sudo tee /etc/apt/sources.list > /dev/null <<EOF
# USTC mirror source - complete replacement of all official sources (Debian 12)
deb http://mirrors.huaweicloud.com/debian/ ${debian_codename} main contrib non-free non-free-firmware
deb http://mirrors.huaweicloud.com/debian/ ${debian_codename}-updates main contrib non-free non-free-firmware
deb http://mirrors.huaweicloud.com/debian/ ${debian_codename}-backports main contrib non-free non-free-firmware

# Security updates also use USTC mirrors
deb http://mirrors.huaweicloud.com/debian-security/ ${debian_codename}-security main contrib non-free non-free-firmware
EOF
    elif [[ "$OS_VERS" == "11" ]]; then
      # Debian 11 does not support non-free-firmware component
    sudo tee /etc/apt/sources.list > /dev/null <<EOF
# USTC mirror source - complete replacement of all official sources (Debian 11)
deb http://mirrors.huaweicloud.com/debian/ ${debian_codename} main contrib non-free
deb http://mirrors.huaweicloud.com/debian/ ${debian_codename}-updates main contrib non-free
deb http://mirrors.huaweicloud.com/debian/ ${debian_codename}-backports main contrib non-free

# Security updates also use USTC mirrors
deb http://mirrors.huaweicloud.com/debian-security/ ${debian_codename}-security main contrib non-free
EOF
    else
      # Other Debian versions use traditional components by default (without non-free-firmware)
    sudo tee /etc/apt/sources.list > /dev/null <<EOF
# USTC mirror source - complete replacement of all official sources (other Debian versions)
deb http://mirrors.huaweicloud.com/debian/ ${debian_codename} main contrib non-free
deb http://mirrors.huaweicloud.com/debian/ ${debian_codename}-updates main contrib non-free
deb http://mirrors.huaweicloud.com/debian/ ${debian_codename}-backports main contrib non-free

# Security updates also use USTC mirrors
deb http://mirrors.huaweicloud.com/debian-security/ ${debian_codename}-security main contrib non-free
EOF
    fi
    
    # Completely disable all source files in /etc/apt/sources.list.d/
    if [[ -d /etc/apt/sources.list.d/ ]]; then
      sudo find /etc/apt/sources.list.d/ -name "*.list" -exec sudo mv {} {}.disabled \; 2>/dev/null || true
      sudo find /etc/apt/sources.list.d/ -name "*.sources" -exec sudo mv {} {}.disabled \; 2>/dev/null || true
    fi
    
    # Remove potentially existing default source configurations
    sudo rm -f /etc/apt/sources.list.d/debian.sources 2>/dev/null || true
  }

  # Configure apt sources - support China mirrors
  apt_setup_mirrors() {
    local network="$1"
    
    if [[ "$network" == "in-china" ]]; then
      console_content_starting "Setting up China apt mirrors..."
      
      # Backup original sources.list (if exists)
      if [[ -f /etc/apt/sources.list ]]; then
        sudo cp /etc/apt/sources.list /etc/apt/sources.list.backup
      fi

      # Completely disable all source files in /etc/apt/sources.list.d/
      if [[ -d /etc/apt/sources.list.d/ ]]; then
        sudo find /etc/apt/sources.list.d/ -name "*.list" -exec sudo mv {} {}.disabled \; 2>/dev/null || true
        sudo find /etc/apt/sources.list.d/ -name "*.sources" -exec sudo mv {} {}.disabled \; 2>/dev/null || true
      fi
      
      if [[ "$OS_NAME" == "Ubuntu" ]]; then
        apt_setup_ubuntu_mirrors_set_china_mirrors
      elif [[ "$OS_NAME" == "Debian" ]]; then
        apt_setup_debian_mirrors_set_china_mirrors
      fi
      
      # Clean cache and rebuild package lists
      sudo apt-get clean
      sudo rm -rf /var/lib/apt/lists/*
      
      console_content_complete
    else
      console_content_starting "Using default apt mirrors..."
      console_content_complete
    fi
  }

  apt_get_update() {
    console_content_starting "Package list is updating..."
    
    eval "sudo apt-get -y update $(console_redirect_output)"

    console_content_complete
  }

  apt_get_install() {
    local label="$1"
    local name="$2"
    local version="$3"

    # shellcheck disable=SC2086,SC2155
    local versions="$(apt-cache madison $name | awk '{print $3}')"

    console_content_starting "$label is installing..."

    if [[ -z "$version" ]] || [[ "$version" == "default" ]]; then
      eval "sudo apt-get -y install $name $(console_redirect_output)"
    else
      # choose version
      if echo "$versions" | grep -q "^${version}$"; then
        eval "sudo apt-get -y install $name=$version $(console_redirect_output)"
      else
        console_content_error "$label $version is not available."
        console_content "Support versions:"
        console_sulines "$versions"
        console_empty_line
        exit 1
      fi
    fi
    console_content_complete
  }

  apt_get_install_tzdata() {
    local tzLocal="$1"

    console_content_starting "tzdata is installing..."

    if [[ -z "$version" ]] || [[ "$version" == "default" ]]; then
      eval "echo $tzLocal | sudo apt-get -y install tzdata $(console_redirect_output)"
    fi
    console_content_complete
  }

  dnf_setup_fedora_mirrors_set_china_mirrors() {
    # Configure Fedora USTC mirror sources
    sudo tee /etc/yum.repos.d/fedora.repo > /dev/null <<EOF
[fedora]
name=Fedora \$releasever - \$basearch
baseurl=http://mirrors.huaweicloud.com/fedora/releases/\$releasever/Everything/\$basearch/os/
enabled=1
metadata_expire=7d
repo_gpgcheck=0
type=rpm
gpgcheck=1
gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-fedora-\$releasever-\$basearch
skip_if_unavailable=False

[fedora-debuginfo]
name=Fedora \$releasever - \$basearch - Debug
baseurl=http://mirrors.huaweicloud.com/fedora/releases/\$releasever/Everything/\$basearch/debug/tree/
enabled=0
metadata_expire=7d
repo_gpgcheck=0
type=rpm
gpgcheck=1
gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-fedora-\$releasever-\$basearch
skip_if_unavailable=False

[fedora-source]
name=Fedora \$releasever - Source
baseurl=http://mirrors.huaweicloud.com/fedora/releases/\$releasever/Everything/source/tree/
enabled=0
metadata_expire=7d
repo_gpgcheck=0
type=rpm
gpgcheck=1
gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-fedora-\$releasever-\$basearch
skip_if_unavailable=False
EOF

        sudo tee /etc/yum.repos.d/fedora-updates.repo > /dev/null <<EOF
[updates]
name=Fedora \$releasever - \$basearch - Updates
baseurl=http://mirrors.huaweicloud.com/fedora/updates/\$releasever/Everything/\$basearch/
enabled=1
repo_gpgcheck=0
type=rpm
gpgcheck=1
metadata_expire=6h
gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-fedora-\$releasever-\$basearch
skip_if_unavailable=False

[updates-debuginfo]
name=Fedora \$releasever - \$basearch - Updates - Debug
baseurl=http://mirrors.huaweicloud.com/fedora/updates/\$releasever/Everything/\$basearch/debug/tree/
enabled=0
repo_gpgcheck=0
type=rpm
gpgcheck=1
metadata_expire=6h
gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-fedora-\$releasever-\$basearch
skip_if_unavailable=False

[updates-source]
name=Fedora \$releasever - Updates Source
baseurl=http://mirrors.huaweicloud.com/fedora/updates/\$releasever/Everything/source/tree/
enabled=0
repo_gpgcheck=0
type=rpm
gpgcheck=1
metadata_expire=6h
gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-fedora-\$releasever-\$basearch
skip_if_unavailable=False
EOF
  }

  dnf_setup_redhat_mirrors() {
    local network="$1"
    local version="$(echo "$OS_VERS" | cut -d '.' -f 1)"

    local repoUrl
    if [[ "$network" == "in-china" ]]; then      
      console_content_starting "Epel repo is installing from China mirrors..."
      repoUrl="https://mirrors.huaweicloud.com/epel/epel-release-latest-$version.noarch.rpm"
    else
      console_content_starting "Epel repo is installing from Fedora Offical mirrors..."
      repoUrl="https://dl.fedoraproject.org/pub/epel/epel-release-latest-$version.noarch.rpm"
    fi

    eval "sudo dnf install -y $repoUrl $(console_redirect_output)"
    console_content_complete

    if [[ "$network" == "in-china" ]]; then      
      console_content_starting "Setting up China EPEL mirrors..."

      sudo tee /etc/yum.repos.d/epel.repo > /dev/null <<EOF
[epel]
name=Extra Packages for Enterprise Linux \$releasever - \$basearch
baseurl=https://mirrors.huaweicloud.com/epel/\$releasever/Everything/\$basearch/
enabled=1
gpgcheck=1
repo_gpgcheck=0
gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-\$releasever
skip_if_unavailable=False
EOF

#       sudo tee /etc/yum.repos.d/epel.repo > /dev/null <<EOF
# [epel]
# name=Extra Packages for Enterprise Linux \$releasever - \$basearch
# baseurl=https://mirrors.ustc.edu.cn/epel/\$releasever/Everything/\$basearch/
# enabled=1
# gpgcheck=1
# repo_gpgcheck=0
# gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-\$releasever
# skip_if_unavailable=False
# EOF

    else
      console_content_starting "Setting up Fedora Offical EPEL mirrors..."

      sudo tee /etc/yum.repos.d/epel.repo > /dev/null <<EOF
[epel]
name=Extra Packages for Enterprise Linux \$releasever - \$basearch
baseurl=https://dl.fedoraproject.org/pub/epel/\$releasever/Everything/\$basearch/
enabled=1
gpgcheck=1
repo_gpgcheck=0
gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-\$releasever
skip_if_unavailable=False
EOF

    fi
    console_content_complete
  }

  # Configure DNF sources - support China mirrors
  dnf_setup_mirrors() {
    local network="$1"

    if [[ "$OS_NAME" == "Fedora" ]]; then
      if [[ "$network" == "in-china" ]]; then      
        console_content_starting "Setting up China DNF mirrors..."

        dnf_setup_fedora_mirrors_set_china_mirrors

        # Clean DNF cache
        eval "sudo dnf clean all $(console_redirect_output)"
      else
        console_content_starting "Using default DNF sources..."
      fi
      console_content_complete
    elif [[ "$OS_NAME" == "RedHat" ]]; then
      dnf_setup_redhat_mirrors "$network"
    elif [[ "$OS_NAME" == "AlibabaCloudLinux" ]]; then
      # Alibaba Cloud Linux typically has appropriate mirror sources pre-configured
      console_content "Alibaba Cloud Linux mirrors are pre-configured."
    fi
  }

  dnf_config_manager_add_repo() {
    local repo_name="$1"
    local repo_file="$2"
    local repo_url="$3"

    # console_content_starting "Adding DNF repository: $repo_name..."

    # eval "sudo dnf config-manager --add-repo $repo_url $(console_redirect_output)"

     # Try multiple methods to add Docker repository
    local repo_added=false
    # Method 1: Try with dnf-plugins-core and config-manager
    if ! $repo_added; then
      if sudo dnf install -y dnf-plugins-core &>/dev/null; then
        if sudo dnf config-manager --add-repo "$repo_url" &>/dev/null; then
          repo_added=true
          console_content "$repo_name repository added successfully."
        fi
      fi
    fi
    # Method 2: Try with newer dnf config-manager syntax
    if ! $repo_added; then
      if sudo dnf config-manager addrepo --from-repofile "$repo_url" &>/dev/null; then
        repo_added=true
        console_content "$repo_name repository added successfully. (newer syntax)"
      fi
    fi
    # Method 3: Download and install repo file manually
    if ! $repo_added; then
      if eval "curl -fsSL \"$repo_url\" -o /tmp/$repo_file $(console_redirect_output)" && \
         sudo mv /tmp/$repo_file /etc/yum.repos.d/ &>/dev/null; then
        repo_added=true
        console_content "$repo_name repository added successfully. (manual download)"
      fi
    fi
    
    # console_content_complete

    if ! $repo_added; then
      console_content_error "$repo_name repository added failed."
      exit 1
    fi
  }

  dnf_update() {
    console_content_starting "Package list is updating..."

    eval "sudo dnf makecache $(console_redirect_output)"

    console_content_complete
  }

  dnf_install() {
    local label="$1"
    local name="$2"
    local version="$3"

    console_content_starting "$label is installing..."

    if [[ -z "$version" ]] || [[ "$version" == "default" ]]; then
      eval "sudo dnf install -y $name $(console_redirect_output)"
    else
      eval "sudo dnf install -y $name-$version $(console_redirect_output)"
    fi
    
    console_content_complete
  }

  download_file() {
    local url="$1"
    local target="$2"
    local dir
    dir=$(dirname "$target")
    local filename
    filename=$(basename "$target")

    if command -v curl &>/dev/null; then
      console_content "Curl is already installed."
    else
      console_content "Curl is not installed. Please install curl first."
      exit 1
    fi

    sudo mkdir -p "$dir"

    console_content "The file '$filename' is downloading..."
    console_content "  from : $url"
    console_content "  to   : $target"
    console_content_starting "..."

    eval "curl -L '$url' -o '$target' $(console_redirect_output)"

    if [ "$(get_param '--debug')" == 'true' ]; then
      console_content "The file '$filename' is downloading..."
      console_content "  from : $url"
      console_content "  to   : $target"
      console_content_starting "..."
    fi

    console_content_complete
  }

  pull_docker_image_from_remote() {
    local docker_image="$1"

    console_content_starting "Image $docker_image is pulling..."
    eval "sudo docker pull $docker_image --platform linux/amd64 $(console_redirect_output)"
    console_content_complete
  }

  pull_docker_image() {
    local docker_image="$1"

    console_key_value "Docker image" "$docker_image"

    if [ "$(get_param '--docker-image-quick-check')" == 'true' ]; then
      local image_exists=$(sudo docker images --format "table {{.Repository}}:{{.Tag}}\t{{.ID}}" | grep "^$docker_image" | wc -l)
      if [ "$image_exists" -gt 0 ]; then
          console_key_value "Local" "Exists"

          # 进一步检查平台架构是否匹配
          local platform_match=$(sudo docker image inspect "$docker_image" --format '{{.Architecture}}' 2>/dev/null | grep -c "amd64")
          
          if [ "$platform_match" -gt 0 ]; then
            console_key_value "Platform" "Match"
          else
            console_key_value "Platform" "Not Match"
            pull_docker_image_from_remote "$docker_image"
          fi
      else
        console_key_value "Local" "Not Exists"
        pull_docker_image_from_remote "$docker_image"
      fi
    else
      pull_docker_image_from_remote "$docker_image"
    fi
  }
}

# Debugger

# print_user_param

# if has_user_param "--a"; then
#   echo "User param --a is set."
# else
#   echo "User param --a is not set."
# fi

# print_default_param

# echo $default

print_help_or_param

network=$(get_param '--network')

db_version=$(get_param '--db-version')

from_hostname=$(get_param '--from-hostname')
from_port=$(get_param '--from-port')
from_username=$(get_param '--from-username')
from_password=$(get_param '--from-password')
from_database=$(get_param '--from-database')

to_hostname=$(get_param '--to-hostname')
to_port=$(get_param '--to-port')
to_username=$(get_param '--to-username')
to_password=$(get_param '--to-password')
to_database=$(get_param '--to-database')

# ------------------------------------------------------------

console_module_title "Temp Directory"

temp=$(get_param '--temp')
sync_file="dump.mysql.$(date +"%Y-%m-%dT%H:%M:%S").sql"

console_key_value "Temp Dir" "$temp"
console_key_value "Sync File" "$sync_file"

if [[ ! -d "$temp" ]]; then
  console_content "Create temp directory."
  mkdir -p "$temp"
fi

console_empty_line

# ------------------------------------------------------------

console_module_title "Check Docker is Installed"

if docker --version &>/dev/null; then
  console_content "Docker is already installed."
else
  console_content "Docker is not installed. Please install docker first."
  exit 1
fi

console_empty_line

console_key_value "Docker CE" "$(docker --version | awk '{print $3}' | sed 's/,//')"
console_key_value "Docker compose" "$(docker compose version | awk '{print $4}')"
console_empty_line

# ------------------------------------------------------------

console_module_title "Pull Docker Image"

docker_image="mysql:$db_version"
pull_docker_image $docker_image
console_empty_line

# ------------------------------------------------------------

console_module_title "Sync by $docker_image"

console_content_starting "Syncing data from $from_hostname to $to_hostname..."

syncCommand="""
# Export data from source database
mysqldump -h $from_hostname -P $from_port -u $from_username -p$from_password $from_database > '/data-backup/$sync_file'

# Import data to target database
mysql -h $to_hostname -P $to_port -u $to_username -p$to_password -e 'DROP DATABASE IF EXISTS $to_database;'
mysql -h $to_hostname -P $to_port -u $to_username -p$to_password -e 'CREATE DATABASE $to_database;'
mysql -h $to_hostname -P $to_port -u $to_username -p$to_password $to_database < '/data-backup/$sync_file'
"""

eval """
sudo docker run --rm \
  --platform linux/amd64 \
  -e 'MYSQL_ROOT_PASSWORD=12345678' \
  -v '$temp/backup:/data-backup' \
  '$docker_image' \
  bash -c \"$syncCommand\" $(console_redirect_output)
"""

console_content_complete
console_empty_line


# ------------------------------------------------------------

console_script_end "Install complete."
